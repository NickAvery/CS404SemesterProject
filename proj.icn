global theta, posx, posy, posz, dirx, diry, dirz, shape, rot

record activation (node, parent, children)


procedure main()
    &window := open("a torus","gl", "bg=black", "size=800,600") 
    Fg("diffuse red")
    epsilon := 0.1
	theta := 0.0
	rot := 45
	
	PushMatrix(&window)
	 Rotate(rot,0.0,0.0,1.0)
     shape := DrawCylinder(0.0, -3.0, -20.0, 5, 0, 1)
	 DrawSphere(0.0, -3.0, -20.0, 5.0)
	PopMatrix(&window)
	
	prevShape := shape

	posx := posy := posz := dirx := diry := dirz := 0
	
	updatecamera(0,0,120,0)
	every i := 1 to 10 do {
			prevShape := newLayer(prevShape)
	}
    while (e := Event(&window)) ~== "q" do {
       case e of { 
				"d": updatecamera(0,0,0,epsilon)
				"a": updatecamera(0,0,0,-epsilon)
				"w": updatecamera(sin(theta)*epsilon*100,0, - cos(theta)*epsilon*100, 0)
				"s": updatecamera(- sin(theta)*epsilon*100,0, cos(theta)*epsilon*100, 0)
				" ": updatecamera(0,5,0,0)
				"c": updatecamera(0,-5,0,0)	
			}
    }
 
    
end

procedure callback(new, old)
	case &eventcode of { #try to use table of procedures or "hani's trick"
		E_MXevent: {
			case &eventvalue of {
				"q" | "\033": stop("user quit")
				38: if delayTime = 1 then {
						delayTime := 5 
					}
					else if delayTime = 0 then {
						delayTime := 1
					}
					else if (delayTime + 5) < 101 then {
						delayTime +:= 5
					}
				40: if delayTime = 5 then {
						delayTime := 1
					}
					else if delayTime = 1 then {
						delayTime := 0
					}
					else if (delayTime - 5) > 1 then {
						delayTime -:= 5
					}
				"d": updatecamera(0,0,0,epsilon)
				"a": updatecamera(0,0,0,-epsilon)
				"w": updatecamera(sin(theta)*epsilon*100,0, - cos(theta)*epsilon*100, 0)
				"s": updatecamera(- sin(theta)*epsilon*100,0, cos(theta)*epsilon*100, 0)
				" ": updatecamera(0,5,0,0)
				"c": updatecamera(0,-5,0,0)	
			}
		}
	}
end

procedure updatecamera(dx,dy,dz,dtheta)
   theta +:= \dtheta
   posx +:= \dx
   posy +:= \dy
   posz +:= \dz
   dirx := posx + sin(theta)
   diry := posy
   dirz := posz - cos(theta)
   Eye(posx,posy,posz,dirx,diry,dirz,0,1,0)
end

procedure newLayer(prevShape)
	change := ?11 -1
	if ?2 = 1 then change := -change
	if prevShape.radius2+change < 0 then change := 0-prevShape.radius2
	PushMatrix(&window)
	Rotate(rot, 0.0, 0.0, 1.0)
	shape := DrawCylinder(prevShape.x, prevShape.y+prevShape.height, prevShape.z, prevShape.height, prevShape.radius2, prevShape.radius2+change)
	PopMatrix(&window)
	Refresh(w)
	return shape
end