$include "evdefs.icn"

link evinit

global theta, posx, posy, posz, dirx, diry, dirz, shape, rot, prevShapes


record activation (node, parent, children)

procedure main(av)
    &window := open("Semester Project","gl", "bg=black", "size=800,600") 
    info := open("Info Screen", "g", "size=300,400")
	Fg("diffuse white")
	DrawSphere(0.0, 0.0, -20.0, 5.0)
    
	epsilon := 0.1
	theta := 0.0
	rot := 45
	posx := posy := posz := dirx := diry := dirz := 0
	updatecamera(0,0,120,0)

	WAttrib("pick=on")
	
	if *av > 0 then
		EvInit(av) | stop("EvInit() is unable to load: ", av[1])
	else
		EvInit() | stop("Unable to monitor")
		
	event_mask := AllocMask
		
	#this is the starting point for all different branch things
	#can change section names to data type for easier lookups

	initSections()

	every i := 1 to 10 do {
		change := ?11 -1
		if ?2 = 1 then change := -change
		if prevShapes["list"].radius2+change < 0 then change := 0-prevShapes["list"].radius2
		newLayer("list", prevShapes["list"].radius2+change)

		change := ?11 -1
		if ?2 = 1 then change := -change
		if prevShapes["table"].radius2+change < 0 then change := 0-prevShapes["table"].radius2
		newLayer("table", prevShapes["table"].radius2+change)
	}
	sectionNum := findWSection("list")
	rotateSect := WindowContents()[sectionNum+6]
	sectionNum2 := findWSection("table")
	rotateSect2 := WindowContents()[sectionNum2+6]
	every i := 1 to 360 do {
		rotateSect.angle +:= 1
		rotateSect2.angle +:= 1
		Refresh(w)
	}
	rotateSect.angle := 90
	rotateSect2.angle := 270
	rotateSect := WindowContents()[sectionNum+5]
	rotateSect2 := WindowContents()[sectionNum2+5]
	every i := 1 to 360 do {
		rotateSect.angle +:= 1
		rotateSect2.angle +:= 1
		Refresh(w)
	}
	WindowContents()[sectionNum+6].angle := 0
	WindowContents()[sectionNum2+6].angle := 180
	rotateSect := WindowContents()[sectionNum+4]
	rotateSect2 := WindowContents()[sectionNum2+4]
	every i := 1 to 360 do {
		rotateSect.angle +:= 1
		rotateSect2.angle +:= 1
		Refresh(w)
	}
	sectionNum := -1
	lastPick := ""
    while (e := Event(&window)) ~== "q" do {
       case e of { 
				"d": updatecamera(0,0,0,epsilon)
				"a": updatecamera(0,0,0,-epsilon)
				"w": updatecamera(sin(theta)*epsilon*100,0, - cos(theta)*epsilon*100, 0)
				"s": updatecamera(- sin(theta)*epsilon*100,0, cos(theta)*epsilon*100, 0)
				" ": updatecamera(0,5,0,0)
				"c": updatecamera(0,-5,0,0)	
				"r": {
					WindowContents()[sectionNum].skip := ((WindowContents()[sectionNum].skip +1)%2)
					Refresh(&window)
				}
				-1:  {
					if \&pick then {
						if &shift then {
							EraseArea(info)

							DrawString(info, 10, 20, &pick)
							DrawString(info, 15, 32, "Total Memory: ")
							DrawString(info, 15, 44, "Last Allocation: ")
							DrawString(info, 15, 56, "Last Deallocation: ")
							if lastPick ~== "" then {
								DrawString(info, 10, 80, lastPick)
								DrawString(info, 15, 92, "Total Memory: ")
								DrawString(info, 15, 104, "Last Allocation: ")
								DrawString(info, 15, 116, "Last Deallocation: ")
							}
						}
						else {
							EraseArea(info)
							lastPick := &pick
							DrawString(info, 10, 20, &pick)
							DrawString(info, 15, 32, "Total Memory: ")
							DrawString(info, 15, 44, "Last Allocation: ")
							DrawString(info, 15, 56, "Last Deallocation: ")
							WindowContents()[sectionNum+2][4] *:= 2
							WindowContents()[sectionNum+2][5] *:= 2
							WindowContents()[sectionNum+2][6] *:= 2
							sectionNum := findWSection(&pick)
							WindowContents()[sectionNum+2][4] /:= 2
							WindowContents()[sectionNum+2][5] /:= 2
							WindowContents()[sectionNum+2][6] /:= 2
							Refresh(&window)
						}
					}
				}
				#rotate - x
				"j": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+4].angle -:= 1
					Refresh(x)
				}
				#rotate + x
				"u": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+4].angle +:= 1
					Refresh(x)
				}
				#rotate - y
				"k": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+5].angle -:= 1
					Refresh(x)
				}
				#rotate + y
				"i": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+5].angle +:= 1
					Refresh(x)
				}
				#rotate - z
				"l": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+6].angle -:= 1
					Refresh(x)
				}
				#rotate + z
				"o": {
					if sectionNum ~= -1 then
						WindowContents()[sectionNum+6].angle +:= 1
					Refresh(x)
				}
			}
    }
	
end


procedure EvMon(event_mask)
	while EvGet(event_mask) do{
		case &eventcode of {
			#"q" | "\033": stop("user quit")
			
			E_List   :{
				write("List Allocated")
				change := 1
				prevShape := newLayer(prevShape, "list", prevShape.radius2+change)
				
			
			}
			E_Lelem  : {write("List Element Allocated")}
			E_File   : {write("File Allocated")}
			E_Real   : {write("Real Allocated")}
			E_Record : {write("Record Allocated")}
			E_Selem  : {write("Set Element Allocated")}
			E_Set    : {write("Set Allocated")}
			E_Slots  : {write("Hash Header Allocated")}
			E_Table  : {write("Table Allocated")}
			E_Telem  : {write("Table Element Allocated")}
			E_Tvsubs : {write("Substring tv Allocated")}
			E_Tvtbl  : {write("Table-element tv Allocated")}
			E_Cset   : {write("Cset Allocated")}
			E_Refresh: {write("Refresh Allocated")}
			E_String : {write("String Allocated")}
			E_Coexpr : {write("Co-expression Allocated")}
		}

	}
end

#usual update camera function
procedure updatecamera(dx,dy,dz,dtheta)
   theta +:= \dtheta
   posx +:= \dx
   posy +:= \dy
   posz +:= \dz
   dirx := posx + sin(theta)
   diry := posy
   dirz := posz - cos(theta)
   Eye(posx,posy,posz,dirx,diry,dirz,0,1,0)
end

#helper for creating all the different data type sections
procedure initSections()
	prevShapes := table()
	
	WSection(&window, "list")
	 PushMatrix(&window)
	  Fg("diffuse red")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(0.0, 1.0, 0.0, 0.0)
	  Rotate(0.0, 0.0, 1.0, 0.0)
	  Rotate(0.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["list"] := shape
	
	WSection(&window, "table")
	 PushMatrix(&window)
	  Fg("diffuse yellow")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(0.0, 1.0, 0.0, 0.0)
	  Rotate(0.0, 0.0, 1.0, 0.0)
	  Rotate(180.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["table"] := shape
	
	WSection(&window, "string")
	 PushMatrix(&window)
	  Fg("diffuse orange")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(90.0, 1.0, 0.0, 0.0)
	  Rotate(0.0, 0.0, 1.0, 0.0)
	  Rotate(0.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["string"] := shape
	
	WSection(&window, "real")
	 PushMatrix(&window)
	  Fg("diffuse green")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(90.0, 1.0, 0.0, 0.0)
	  Rotate(0.0, 0.0, 1.0, 0.0)
	  Rotate(180.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["real"] := shape
	
	WSection(&window, "record")
	 PushMatrix(&window)
	  Fg("diffuse blue")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(0.0, 1.0, 0.0, 0.0)
	  Rotate(0.0, 0.0, 1.0, 0.0)
	  Rotate(90.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["record"] := shape
	
	WSection(&window, "set")
	 PushMatrix(&window)
	  Fg("diffuse purple")
	  Translate(0.0, 0.0, -20.0)
	  Rotate(0.0, 1.0, 0.0, 0.0)
	  Rotate(180.0, 0.0, 1.0, 0.0)
	  Rotate(90.0, 0.0, 0.0, 1.0)
      shape := DrawCylinder(0.0, 0.0, 0.0, 5, 0, 1)
	 PopMatrix(&window)
	WSection(&window)
	prevShapes["set"] := shape
end

#add a new layer to a section given a name and new radius to go to. uses the previous layer to build on, so make sure to save the result
procedure newLayer(sectionName, newRadius)
	prevShape := prevShapes[sectionName]
	DrawCylinder(prevShape.x, prevShape.y+prevShape.height, prevShape.z, prevShape.height, prevShape.radius2, newRadius)
	shape := pull(WindowContents())
	addToWSection(shape, sectionName)
	Refresh(w)
	prevShapes[sectionName] := shape
end

#add a given shape to a section with a section name.
procedure addToWSection(shape, sectionName)
	sectionNum := findWSection(sectionName)
	if sectionNum ~= -1 then {
		sect := WindowContents()[sectionNum]
		insert(WindowContents(), sectionNum+sect.count-1, shape) # -1 for the pop matrix
		sect.count +:= 1
		fixParentSections(sectionNum, sect)
	}
end


#return the index of the section with section name. if it wasnt found, return -1
procedure findWSection(sectionName)
	wlist := WindowContents()
	i := 1
	every x := !wlist do { 
		if type(x) == "gl_mark" then {
			if x.name == "Mark" then {
				if x.section_name == sectionName then {
					return i
				}
			}
		}
		i +:= 1
	}
	return -1
end

#meant to update parent sections for things like nested sections. Shouldnt have to use it for our project, but good to have
#not exactly sure if it works
procedure fixParentSections(sectionNum, sect)
	notParent := 2 		#1 if false, 2 if true
	i := sect.depth
	wlist := WindowContents()
	every x := !wlist do {
		if i = 1 then break
		if type(x) == "gl_mark" then {
			if x.name == "EndMark" then notParent := 1
			if x.name == "Mark" then {
				if notParent = 2 then x.count +:= 1
				if notParent = 1 then notParent := 2
			}
		}
	}
end